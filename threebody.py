import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
import pdb

def update_velocity(pos, grav_const, mass_obj, mass_sat1, mass_sat2):
    """
    Returns results for newton's second law for two satellites experiencing
    gravitational forces. The forces are generated by an object centered at the
    origin the equations are:

    d2x/dt2 = F_x/M_sat
    d2y/dt2 = F_y/M_sat

    with:

    F = G * M_1 * M_2 / r^2

    Symbols:

    F = Gravitational force given in (su AU yr^-2)
    G = Gravitational constant = 6.674e-11 (AU^3 su^-1 yr^-2)
    M_obj = Mass of the object the satellite orbits given in killograms (su)
    M_sat = Mass of the satellite given in killograms (su)
    r = distance from object to satelite (AU)

    Parameters:
    -----------
    pos = 1d array of floats (6,)
        contains x and y positions of the satellites and object
    grav_const = float
        gravitational constant
    mass_obj = float
        Mass of the object orbited by the satellite
    mass_sat = float
        Mass of satellite

    Returns:
    --------

    new_vel = 1d array (2,)
        updated velocities in x and y
    """
    # split our position vector into smaller per object vectors
    pos1 = pos[0,:] # Satellite 1
    pos2 = pos[1,:] # Satellite 2
    pos0 = pos[2,:] # "Central" Object

    # forces from satellite to satellite
    dist12 = ((pos1[0]-pos2[0])**2+(pos1[1]-pos2[1])**2)**0.5
    force_x2on1 = -grav_const * mass_sat1 * mass_sat2 * (pos1[0]-pos2[0]) / dist12**3
    force_y2on1 = -grav_const * mass_sat1 * mass_sat2 * (pos1[1]-pos2[1]) / dist12**3
    force_x1on2 = -force_x2on1
    force_y1on2 = -force_y2on1

    # force of the central object on the first satellite
    dist1 = ((pos1[0]-pos0[0])**2+(pos1[1]-pos0[1])**2)**0.5
    force_x1 = -grav_const * mass_sat1 * mass_obj * (pos1[0]-pos0[0]) / dist1**3
    force_y1 = -grav_const * mass_sat1 * mass_obj * (pos1[1]-pos0[1]) / dist1**3

    # force of the central object on the second satellite
    dist2 = ((pos2[0]-pos0[0])**2+(pos2[1]-pos0[1])**2)**0.5
    force_x2 = -grav_const * mass_sat2 * mass_obj * (pos2[0]-pos0[0]) / dist2**3
    force_y2 = -grav_const * mass_sat2 * mass_obj * (pos2[1]-pos0[1]) / dist2**3

    # update velocities
    ddx1 = (force_x1 + force_x2on1) / mass_sat1
    ddy1 = (force_y1 + force_y2on1) / mass_sat1
    ddx2 = (force_x2 + force_x1on2) / mass_sat2
    ddy2 = (force_y2 + force_y1on2) / mass_sat2
    ddx0 = -(force_x1 + force_x2) / mass_obj
    ddy0 = -(force_y1 + force_y2) / mass_obj

    ret1 = np.asarray([ddx1, ddy1])
    ret2 = np.asarray([ddx2, ddy2])
    ret0 = np.asarray([ddx0, ddy0])

    ret_pos = np.vstack((pos1, pos2, pos0))
    forces1 = np.hstack((force_x1, force_y1))
    forces2 = np.hstack((force_x2, force_y2))
    forces21 = np.hstack((force_x2on1, force_y2on1))
    forces12 = np.hstack((force_x1on2, force_y1on2))
    ret_force = np.vstack((forces1, forces2, forces21, forces12))

    return np.vstack((ret1, ret2, ret0)), ret_force, ret_pos

# masses
mass_earth = 5.974e24/1.989e30 # solar units (su)
mass_jupiter = 1.90e27/1.989e30 # solar units (su)
mass_sun = 1. # su

jmass_mult = 1000.
mass_jupiter = jmass_mult * mass_jupiter

# gravitational constant
grav = 39.478 # AU^3 yr^-2 su^-1

# starting positions
earthx_start = 1.0 # AU
earthy_start = 0. # AU
jupiterx_start = 5.2 # AU
jupitery_start = 0. # AU
sunx_start = 0. # AU
suny_start = 0. # AU

# we need these for calculating starting y velocity
earth_dist = (earthx_start**2 + earthy_start**2)**0.5
jupiter_dist = (jupiterx_start**2 + jupitery_start**2)**0.5

# starting velocities
earthx_vel = 0. # AU/year
earthy_vel = 2 * np.pi * earth_dist # AU/year
jupiterx_vel = 0. # AU/year
jupitery_vel = 2. * np.pi * jupiterx_start / 11.86 # AU/year
sunx_vel = 0. # AU/year
# The sun's starting y velocity is based on conservation of momentum with The
# other bodies. We solve m_E * v_Ey + m_J * v_Jy + m_S * v_Sy = 0
suny_vel = - (mass_earth * earthy_vel + mass_jupiter * jupitery_vel) / mass_sun

# time stuff
start_time = 0 # years
end_time = 4000. # years
time_step = 0.0001 # years
times = np.arange(start_time, end_time+time_step, time_step)

# adjust start positions so our orgin is placed at the beginning center of mass
center_of_mass_x = ((mass_earth * earthx_start +
                    mass_jupiter * jupiterx_start) /
                    (mass_earth + mass_jupiter + mass_sun))
earthx_adjusted = earthx_start - center_of_mass_x
jupiterx_adjusted = jupiterx_start - center_of_mass_x
sunx_adjusted = sunx_start - center_of_mass_x


# arrays to hold our positions and velocities over time for earth
pos = np.zeros((times.shape[0], 3, 2))
pos[0, 0, 0] = earthx_adjusted
pos[0, 0, 1] = earthy_start
pos[0, 1, 0] = jupiterx_adjusted
pos[0, 1, 1] = jupitery_start
pos[0, 2, 0] = sunx_adjusted
pos[0, 2, 1] = suny_start
vel = np.zeros((times.shape[0], 3, 2))
vel[0, 0, 0] = earthx_vel
vel[0, 0, 1] = earthy_vel
vel[0, 1, 0] = jupiterx_vel
vel[0, 1, 1] = jupitery_vel
vel[0, 2, 0] = sunx_vel
vel[0, 2, 1] = suny_vel

forces = np.zeros((times.shape[0], 4, 2))
for time in np.arange(len(times))[1:]:
    accel, forces[time-1,:,:], func_pos = update_velocity(pos[time-1,:,:],grav,
                                                              mass_sun,
                                                              mass_earth,
                                                              mass_jupiter)
    new_vel = vel[time-1,:,:] + time_step * accel
    new_pos = pos[time-1,:] + new_vel * time_step
    vel[time,:,:] = new_vel
    pos[time,:,:] = new_pos

# Animation ####################################################################
# plt.figure()
# fig, ax = plt.subplots(figsize=(6,6))
#
# ax.set_xlim([-12, 12])
# ax.set_ylim([-12, 12])
# inner = ax.scatter(pos[0, 0, 0], pos[0, 0, 1], label = 'Earth')
# sun = ax.scatter(pos[0, 2, 0], pos[0, 2, 1], label = 'Sun')
# outer = ax.scatter(pos[0, 1, 0], pos[0, 1, 1], label = 'Jupiter')
# # inner_trail = ax.scatter(pos[0,0,0], pos[0,0,1], marker='o', s = 0.5)
# # outer_trail = ax.scatter(pos[0,1,0], pos[0,1,1], marker='o', s = 0.5)
#
# def animate(i):
#     inner.set_offsets(np.c_[pos[i,0,0], pos[i,0,1]])
#     outer.set_offsets(np.c_[pos[i,1,0], pos[i,1,1]])
#     sun.set_offsets(np.c_[pos[i,2,0], pos[i,2,1]])
#     if i % 150 == 0:
#         in_arr1 = ax.arrow(pos[i,2,0], pos[i,2,1], -forces[i,0,0]*1e5, -forces[i,0,1]*1e5)
#         in_arr2 = ax.arrow(pos[i,2,0], pos[i,2,1], -forces[i,1,0]*1e5, -forces[i,1,1]*1e5)
#
#     # inner_trail.set_offsets(np.c_[pos[:i:50,0,0], pos[:i:50,0,1]])
#     # outer_trail.set_offsets(np.c_[pos[:i:50,1,0], pos[:i:50,1,1]])
#
#
# anim = FuncAnimation(fig, animate, interval=1, frames = times.shape[0] - 1)
# ax.legend()
# ax.set_xlabel('x position (AU)')
# ax.set_ylabel('y position (AU)')
# plt.draw()
# plt.show()
################################################################################

plt.figure()
fig, ax = plt.subplots(figsize=(6,6))
earth = ax.plot(pos[:,0,0], pos[:,0,1], linewidth=0.3, label = 'Earth')
sun = ax.plot(pos[:,2,0], pos[:, 2, 1], c='orange', linewidth=0.3, label='Sun')
jupiter = ax.plot(pos[:,1,0], pos[:,1,1], linewidth=0.3, c='r', label='Jupiter')
ax.set_xlim((-120, 120))
ax.set_ylim((-120, 120))
ax.set_xlabel('x position (AU)')
ax.set_ylabel('y position (AU)')
ax.legend(loc='best')
plt.savefig('three_body.png')

# figure to track total momentum over time
per_object_x = vel[:, :, 0] * np.asarray([mass_earth, mass_jupiter, mass_sun])
per_object_y = vel[:, :, 1] * np.asarray([mass_earth, mass_jupiter, mass_sun])
totalx = np.sum(per_object_x, axis = 1)
totaly = np.sum(per_object_y, axis = 1)
total_momentum = (totalx**2 + totaly**2)**0.5

plt.figure()
fig, ax = plt.subplots()
mom = ax.plot(times, total_momentum)
ax.set_ylabel('Momentum (solar units * (AU/year))')
ax.set_xlabel('Time (years)')
plt.savefig('momentum.png')
