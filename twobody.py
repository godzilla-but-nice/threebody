import matplotlib.pyplot as plt
import numpy as np
from matplotlib.animation import FuncAnimation
import pdb

def update_velocity(pos, grav_const, mass_obj, mass_sat):
    """
    Returns results for newton's second law for a satellite experiencing a
    gravitational force. The force is generated by an object centered at the
    origin the equations are:

    d2x/dt2 = F_x/M_sat
    d2y/dt2 = F_y/M_sat

    with:

    F = G * M_obj * M_sat / r^2

    Symbols:

    F = Gravitational force given in (su AU yr^-2)
    G = Gravitational constant = 6.674e-11 (AU^3 su^-1 yr^-2)
    M_obj = Mass of the object the satellite orbits given in killograms (su)
    M_sat = Mass of the satellite given in killograms (su)
    r = distance from object to satelite (AU)

    Parameters:
    -----------
    pos = 1d array of floats (2,)
        contains x and y positions of the satellite
    grav_const = float
        gravitational constant
    mass_obj = float
        Mass of the object orbited by the satellite
    mass_sat = float
        Mass of satellite

    Returns:
    --------

    new_vel = 1d array (2,)
        updated velocities in x and y
    """
    # calculate forces at this time to allow non-circular orbits
    dist = (pos[0]**2+pos[1]**2)**0.5
    force = -(grav_const * mass_obj * mass_sat) / dist**2
    angle = np.arctan2(pos[1], pos[0])

    forcex = force * np.cos(angle)
    forcey = force * np.sin(angle)

    # update velocities
    ddx = forcex / mass_sat
    ddy = forcey / mass_sat

    #pdb.set_trace()

    return np.asarray([ddx, ddy])

# masses
mass_earth = 5.974e24/1.989e30 # solar units (su)
mass_sun = 1 # su

# gravitational constant
grav = 39.478 # AU^3 yr^-2 su^-1

# starting positions
posx_start = 1 # AU
posy_start = 0 # AU
start_dist = (posx_start**2 + posy_start**2)**0.5

# starting velocities
velx_start = 0 # AU/year
vely_start = 2 * np.pi * start_dist # AU/year

# time stuff
start_time = 0 # years
end_time = 5 # years
time_step = 0.002 # years
times = np.arange(start_time, end_time+time_step, time_step)

# arrays to hold our positions and velocities over time
pos = np.zeros((times.shape[0], 2))
pos[0, 0] = posx_start
pos[0, 1] = posy_start
vel = np.zeros((times.shape[0], 2))
vel[0, 0] = velx_start
vel[0, 1] = vely_start

for time in np.arange(len(times))[1:]:
    new_vel = vel[time-1,:] + (time_step * update_velocity(pos[time-1,:],
                                                grav, mass_sun, mass_earth))
    new_pos = pos[time-1,:] + new_vel * time_step
    vel[time,:] = new_vel
    pos[time,:] = new_pos

# Animation ####################################################################
# plt.figure()
# fig, ax = plt.subplots(figsize=(6,6))
# ax.set_xlim([-1.2, 1.2])
# ax.set_ylim([-1.2, 1.2])
# satellite = ax.scatter(pos[0, 0], pos[0, 1])
# sun = ax.scatter([0.], [0.], marker='o', s=100)
# #trail = ax.scatter(pos[0,0], pos[0,1], marker='o', s = 1)
#
# def animate(i):
#     #trail.set_offsets(np.c_[pos[:i:10,0], pos[:i:10,1]])
#     satellite.set_offsets(np.c_[pos[i,0], pos[i,1]])
#
# anim = FuncAnimation(fig, animate, interval=10, frames=len(times)-1)
#
# ax.legend()
# ax.set_xlabel('x position (AU)')
# ax.set_ylabel('y position (AU)')
#
# plt.draw()
# plt.show()
################################################################################

plt.figure()
fig, ax = plt.subplots(figsize=(6,6))
ax.plot(pos[:,0], pos[:,1], label='Earth')
ax.scatter([0.], [0.], c='orange', label='Sun')
ax.legend(loc='best')
ax.set_xlabel('x (AU)')
ax.set_ylabel('y (AU)')
plt.savefig('twobody.png')
